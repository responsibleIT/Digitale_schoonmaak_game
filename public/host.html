<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboardgame ‚Äì Host</title>
  <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
  <main class="container">
    <h1>Host Dashboard</h1>

    <div class="card">
      <div class="stack">
        <button id="start" class="primary">Start sessie</button>

        <!-- Session box shown after host:start -->
        <div id="sessionBox" class="hidden">
          <h2>Sessie ID: <span id="sessionId"></span></h2>
          <p class="muted">Laat spelers dit ID invullen op het join-scherm.</p>

          <section class="card" style="background: transparent; border-color: var(--border);">
            <h3>Lobby</h3>
            <p class="muted">Deelnemers die zijn aangesloten:</p>
            <ul id="hostLobbyUsers"></ul>
          </section>

          <div class="row gap">
            <button id="begin" class="primary">Start het spel</button>
            <button id="refreshStats" class="secondary" title="Vraag een statssnapshot op">Vernieuw stats</button>
            <button id="end" class="danger">Be√´indig sessie</button>
          </div>

          <section class="stats">
            <h3>Leaderboard</h3>
            <!-- old simple list kept (not used now but harmless) -->
            <ol id="leaderboard"></ol>
            <p id="totals" class="muted"></p>

            <!-- New visual containers -->
            <div id="podium"></div>
            <div id="lbWrap"></div>
            <div id="totalsHost"></div>
          </section>
        </div>
      </div>
    </div>
  </main>

  <script type="module" src="/js/socket.js"></script>
  <script type="module">
    import { socket, connectSocket } from "/js/socket.js";
    connectSocket();

    const $ = (s) => document.querySelector(s);
    const startBtn    = $("#start");
    const beginBtn    = $("#begin");
    const endBtn      = $("#end");
    const refreshBtn  = $("#refreshStats");
    const sessionBox  = $("#sessionBox");
    const sessionIdEl = $("#sessionId");
    const lobbyList   = $("#hostLobbyUsers");
    const podiumEl    = $("#podium");
    const tableWrap   = $("#lbWrap");
    const totalsEl    = $("#totalsHost");

    let sessionId;

    function setSessionId(id){
      sessionIdEl.textContent = id;
      sessionBox.classList.remove("hidden");
    }

    // --- Buttons
    startBtn?.addEventListener("click", () => socket.emit("host:start"));
    beginBtn?.addEventListener("click", () => {
      if (!sessionId) return;
      socket.emit("host:begin", { sessionId });
      socket.emit("presence:request", { sessionId }); // safety
    });
    refreshBtn?.addEventListener("click", () => sessionId && socket.emit("presence:request", { sessionId }));
    endBtn?.addEventListener("click", () => sessionId && socket.emit("host:end", { sessionId }));

    // --- Session ID from server
    socket.on("host:sessionId", (p) => {
      sessionId = p.sessionId;
      setSessionId(sessionId);
      socket.emit("presence:request", { sessionId });
    });

    // --- Presence: show readiness + gate Start
    socket.on("presence", ({ users, phase, allReady }) => {
      if (beginBtn) {
        beginBtn.disabled = !allReady;
        beginBtn.style.opacity = allReady ? "1" : ".6";
        beginBtn.title = allReady ? "" : "Wachten tot iedereen klaar is‚Ä¶";
      }

      if (lobbyList) {
        lobbyList.innerHTML = (users ?? []).map(u => {
          const st = u.status || {};
          const state = st.ready ? "‚úÖ Ready"
            : st.selected ? `‚è≥ ${st.loadingPct ?? 0}% (${st.filesCount ?? 0})`
            : "‚¨ú Not selected";
          return `<li>${u.displayName} ‚Äî ${state}</li>`;
        }).join("");
      }
    });

    // --- Stats: render + small confetti every update
    socket.on("stats", (snap) => {
      renderStats(snap);
      confettiBurst(24, 600); // keep it lively
    });

    // --- Big celebration events
    socket.on("game:event", (ev) => {
      // ev = { kind, byName, size?, streak?, text? }
      switch (ev.kind) {
        case "milestone:100MB":
          bigOverlay(`üéâ ${ev.byName} haalde 100 MB!`, "Lekker bezig!", "#18c1be");
          break;
        case "milestone:500MB":
          bigOverlay(`üöÄ ${ev.byName} knalt 500 MB!!`, "Legend!", "#ffb703");
          break;
        case "streak:5":
          bigOverlay(`üî• ${ev.byName} heeft een 5x streak!`, "Combo time!", "#ff7096");
          break;
        case "bigfile":
          bigOverlay(`üì¶ ${ev.byName} verwijderde ${(ev.size/1_000_000).toFixed(0)} MB`, "Massive!", "#8f85ff");
          break;
        default:
          bigOverlay(ev.text || "Nice!", ev.byName || "", "#8f85ff");
      }
    });

    // ---------- RENDERING ----------
    function renderStats(snap){
      const lb = [...(snap.leaderboard || [])].sort((a,b)=>b.bytes-a.bytes);

      // 1) Podium (1st, 2nd, 3rd left‚Üíright)
      const top = lb.slice(0,3);
      if (podiumEl) {
        podiumEl.innerHTML = `
          <div class="podium">
            ${[0,1,2].map(i => {
              const p = top[i] || { displayName: "-", bytes: 0 };
              return `
                <div class="step step-${i}">
                  <div class="place">${["1st","2nd","3rd"][i]}</div>
                  <div class="name">${p.displayName}</div>
                  <div class="score">${(p.bytes/1_000_000).toFixed(1)} MB</div>
                </div>`;
            }).join("")}
          </div>`;
      }

      // 2) Full table (everyone)
      if (tableWrap) {
        tableWrap.innerHTML = `
          <table class="leader">
            <thead>
              <tr><th>#</th><th>Naam</th><th>MB</th><th>Items</th><th>Streak</th><th>Tempo</th><th>Grootste</th></tr>
            </thead>
            <tbody>
              ${lb.map((r,idx)=>`
                <tr class="${idx===0 ? "row-first" : ""}">
                  <td>${idx+1}</td>
                  <td>${r.displayName}</td>
                  <td>${(r.bytes/1_000_000).toFixed(1)}</td>
                  <td>${r.items}</td>
                  <td>${r.streak}</td>
                  <td>${r.ratePerMin.toFixed(1)}/min</td>
                  <td>${
                    r.largestName
                      ? `${r.largestName} (${r.largestSize ? (r.largestSize/1_000_000).toFixed(0)+"MB" : "-"})`
                      : "-"
                  }</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
          <div class="totals">
            <div><strong>Totaal:</strong> ${(snap.totalBytes/1_000_000).toFixed(0)} MB over ${snap.totalItems} items</div>
            <div><strong>CO‚ÇÇ bespaard (speels):</strong> ${ (snap.totalBytes/1_000_000_000).toFixed(2) } kg</div>
          </div>`;
      }
    }

    // ---------- FX ----------
    function confettiBurst(n = 120, dur = 1200) {
      let c = document.getElementById("confetti");
      if (!c) {
        c = document.createElement("canvas");
        c.id = "confetti";
        c.className = "confetti";
        document.body.appendChild(c);
      }
      const ctx = c.getContext("2d");
      c.width = innerWidth; c.height = innerHeight;
      const parts = Array.from({ length: n }, () => ({
        x: Math.random() * c.width,
        y: -10 - Math.random() * 80,
        vx: (Math.random() - .5) * 8,
        vy: 3 + Math.random() * 6,
        s: 4 + Math.random() * 6,
        a: 1,
        rot: Math.random() * Math.PI,
        vr: (Math.random() - .5) * .3
      }));
      const t0 = performance.now();
      (function tick(t){
        const dt = (t - (tick.t||t)) / 16; tick.t = t;
        ctx.clearRect(0,0,c.width,c.height);
        parts.forEach(p=>{
          p.x += p.vx*dt; p.y += p.vy*dt; p.rot += p.vr*dt; p.a -= 0.008*dt;
          ctx.save(); ctx.globalAlpha = Math.max(0,p.a);
          ctx.translate(p.x,p.y); ctx.rotate(p.rot);
          ctx.fillStyle = ["#8f85ff","#6a5ae0","#18c1be","#ffb703","#ff7096"][p.s|0 % 5];
          ctx.fillRect(-p.s/2,-p.s/2,p.s,p.s);
          ctx.restore();
        });
        if (performance.now() - t0 < dur) requestAnimationFrame(tick);
        else ctx.clearRect(0,0,c.width,c.height);
      })(performance.now());
    }

    function bigOverlay(message, sub = "", color = "#8f85ff") {
      let o = document.getElementById("fxOverlay");
      if (!o) {
        o = document.createElement("div");
        o.id = "fxOverlay";
        o.className = "fx-overlay";
        o.innerHTML = `<div class="fx-inner"><div class="fx-title"></div><div class="fx-sub"></div></div>`;
        document.body.appendChild(o);
      }
      o.querySelector(".fx-title").textContent = message;
      o.querySelector(".fx-sub").textContent = sub;
      o.style.setProperty("--fx-color", color);
      o.classList.remove("hide");
      o.classList.add("show");
      confettiBurst(220, 2000);
      // fun little haptic using Vibration API (best-effort)
      if (navigator.vibrate) navigator.vibrate([40,20,40,20,80]);
      setTimeout(()=>o.classList.add("hide"), 2200);
    }

    // simple toast (kept, used rarely)
    function toast(title, text){
      const t = document.createElement("div");
      t.className = "toast";
      t.innerHTML = `<div class="toast-title">${title}</div><div>${text}</div>`;
      document.body.appendChild(t);
      setTimeout(() => t.classList.add("show"), 10);
      setTimeout(() => { t.classList.remove("show"); setTimeout(()=>t.remove(), 300); }, 3000);
    }
  </script>
</body>
</html>
